---
title: UI系列
categories: 
  - 技术
  - iOS基础知识
tags: 
  - null
date: 2023-08-13 14:05:43
permalink: /pages/1a56ed/
---
## 事件的传递（响应链）

当你点击了屏幕会产生一个触摸事件，系统会将该事件加入到一个由UIApplication管理的事件队列中，UIApplication会从消息队列里取事件分发下去，首先传给UIWindow，UIWindow会使用hitTest:withEvent:方法找到此次触摸事件初始点所在的视图，找到这个视图之后他就会调用视图的touchesBegan:withEvent:方法来处理事件。以消息的形式将事件发送给第一响应者，使其有机会首先处理事件。如果第一响应者没有进行处理，系统就将事件（通过消息）传递给响应者链中的下一个响应者，看看它是否可以进行处理。（这是一个完整的事件响应链流程

用户点击屏幕时，产生一个触摸事件，事件加入到一个由UIApplication管理的事件队列中

UIApplication从事件队列中取出最前面的事件进行分发处理，先发送事件给应用程序的主窗口(UIWindow)

主窗口会调用hitTest:withEvent:方法在视图(UIView)层次结构中找到一个最合适的UIView来处理触摸事件



为什么是队列而不是栈？
因为队列的特定是先进先出，先产生的事件先处理才符合常理，所以把事件添加到队列。


如果hitTest:withEvent:找到的第一响应者initial view没有处理该事件，那么事件会沿着响应者链向上传递：第一响应者 -> 父视图 -> 视图控制器，如果传递到最顶级视图还没处理事件，那么就传递给UIWindow处理，若window对象也不处理->交给UIApplication处理，如果UIApplication对象还不处理，就丢弃该事件。

### 既然理解了事件传递流程，那什么是事件响应链又是什么？

提到事件响应链 ，先得说下 UIResponder 这个类，UIResponder是所有响应者对象的基类，UIResponder类定义了很多处理事件方法和抽象接口。 nextResponder 就是响应链里最重要的方法。

iOS系统在处理事件时，通过UIApplication对象和每个UIWindow对象的sendEvent:方法将事件以消息的形式分发给具体处理此事件的第一响应者，使其有机会首先处理事件。如果第一响应者没有进行处理，第一响应者将事件将处理事件的责任传递给下一个，更高级的对象,即当前responder对象的nextResponder。

通过下面代码打印的结果可以看到响应链的传递路径。 事件通过UIResponder实现响应，就是响应链。
复制代码

### 既然UIResponder这个类在响应链里这么重要，那再问一个跟UIResponder相关的简单问题，UIButton的父类或UIButton 继承关系是什么？

UIButton UIDatePicker这些控件 都继承了 UIControl， UIControl 继承于 UIView ,UIView继承于UIResponder。

### 那视图上有很多子视图，那怎么判断是哪个子视图对事件作出响应呢？

用View的SubViews这个成员变量来遍历子视图实现。遍历的方式是用倒序方式来 遍历。 最后添加到UIWindow中的视图会最先遍历到。 可以理解为递归调用。每个视图都会调用自己的子视图的·hitTest方法来查找是否是自己响应了事件。

(hitTest:withEvent:其实是UIView的一个方法，UIWindow继承自UIView，因此主窗口UIWindow也是属于视图的一种)






##  drawrect & layoutsubviews调用时机

layoutSubviews:(相当于layoutSubviews()函数)在以下情况下会被调用：

- init初始化不会触发layoutSubviews。
- addSubview会触发layoutSubviews。
- 设置view的Frame会触发layoutSubviews (frame发生变化触发)。
- 滚动一个UIScrollView会触发layoutSubviews。
- 旋转Screen会触发父UIView上的layoutSubviews事件。
- 改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。
- 直接调用setLayoutSubviews。

drawrect:(drawrect()函数)在以下情况下会被调用：

- drawrect:是在UIViewController的loadView:和ViewDidLoad:方法之后调用.
- 当我们调用[UIFont的 sizeToFit]后,会触发系统自动调用drawRect:
- 当设置UIView的contentMode或者Frame后会立即触发触发系统调用drawRect:
- 直接调用setNeedsDisplay设置标记 或setNeedsDisplayInRect:的时候会触发drawRect:
知识点扩充: 当我们操作drawRect方法的时候实际是在操作内存中存放视图的backingStore区域,用于后续图形的渲染操作,如果不理解可以看下UIView的渲染过程.

## imageName&imageWithContentsOfFile区别

| 区别 | UIView | imageWithContentsOfFile |
| --- | --- | --- |
| 不同点 | 会图片缓存到内存中 | 无缓存 |

## 多个相同的图片，会重复加载吗

不会,GPU有 像素点缓存的mask.

## 图片是什么时候解码的，如何优化

是加载到内存中,从UIImge->CGImage->CGImageSourceCreateWithData(data) 创建ImageSource变成bitmap位图,这些工作都是CoreAnimation在图片被加载到内存中存在在backingStore里,送给GPU流水线处理之前被解码.

如何优化
自己手动操作图片的编码API

CGImageSource开头的哪些,根据合理利用时机和操作系统资源调整出一套缓存小加载快的库.


## UIView 和 CALayer 是什么关系？

UIView 继承 UIResponder，而 UIResponder 是响应者对象，可以对iOS 中的事件响应及传递，CALayer 没有继承自 UIResponder，所以 CALayer 不具备响应处理事件的能力。CALayer 是 QuartzCore 中的类，是一个比较底层的用来绘制内容的类，用来绘制UI

UIView 对 CALayer 封装属性，对 UIView 设置 frame、center、bounds 等位置信息时，其实都是UIView 对 CALayer 进一层封装，使得我们可以很方便地设置控件的位置；例如圆角、阴影等属性， UIView 就没有进一步封装，所以我们还是需要去设置 Layer 的属性来实现功能。

UIView 是 CALayer 的代理，UIView 持有一个 CALayer 的属性，并且是该属性的代理，用来提供一些 CALayer 行的数据，例如动画和绘制。

## .与->有何区别

.（点语法）是访问类的属性，本质是调用set、get方法。

->是访问成员变量，但成员变量默认受保护，所以常常报错，手动设为public即可解决

->是指针指向其成员的运算符 .是结构体的成员运算符。最大的区别是->前面放的是指针，而.前面跟的是结构体变量