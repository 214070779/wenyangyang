{"remainingRequest":"/Users/yangyangwen/Desktop/wenyangyang/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/yangyangwen/Desktop/wenyangyang/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/yangyangwen/Desktop/wenyangyang/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/yangyangwen/Desktop/wenyangyang/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/yangyangwen/Desktop/wenyangyang/docs/iOS-Summary/Foundation.md?vue&type=template&id=4886587b&","dependencies":[{"path":"/Users/yangyangwen/Desktop/wenyangyang/docs/iOS-Summary/Foundation.md","mtime":1568205954000},{"path":"/Users/yangyangwen/Desktop/wenyangyang/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yangyangwen/Desktop/wenyangyang/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/yangyangwen/Desktop/wenyangyang/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yangyangwen/Desktop/wenyangyang/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/yangyangwen/Desktop/wenyangyang/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_c('h1',{attrs:{\"id\":\"foundation\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#foundation\"}},[_vm._v(\"#\")]),_vm._v(\" Foundation\")]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"_1-nil、nil、nsnull-有什么区别？\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#_1-nil、nil、nsnull-有什么区别？\"}},[_vm._v(\"#\")]),_vm._v(\" 1.nil、NIL、NSNULL 有什么区别？\")]),_vm._v(\" \"),_c('ul',[_c('li',[_c('p',[_vm._v(\"nil、NIL 可以说是等价的，都代表内存中一块空地址。\")])]),_vm._v(\" \"),_c('li',[_c('p',[_vm._v(\"NSNULL 代表一个指向 nil 的对象。\")])])]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"_2-如何实现一个线程安全的-nsmutablearray\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#_2-如何实现一个线程安全的-nsmutablearray\"}},[_vm._v(\"#\")]),_vm._v(\" 2.如何实现一个线程安全的 NSMutableArray?\")]),_vm._v(\" \"),_c('p',[_vm._v(\"NSMutableArray是线程不安全的，当有多个线程同时对数组进行操作的时候可能导致崩溃或数据错误\")]),_vm._v(\" \"),_c('ul',[_c('li',[_c('p',[_vm._v(\"线程锁：使用线程锁对数组读写时进行加锁\")])]),_vm._v(\" \"),_c('li',[_c('p',[_vm._v(\"派发队列：在《Effective Objective-C 2.0..》书中第41条：多用派发队列，少用同步锁中指出：使用“串行同步队列”（serial synchronization queue），将读取操作及写入操作都安排在同一个队列里，即可保证数据同步。而通过并发队列，结合GCD的栅栏块（barrier）来不仅实现数据同步线程安全，还比串行同步队列方式更高效。\")])])]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"_3-atomic-修饰的属性是绝对安全的吗？为什么？\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#_3-atomic-修饰的属性是绝对安全的吗？为什么？\"}},[_vm._v(\"#\")]),_vm._v(\" 3.atomic 修饰的属性是绝对安全的吗？为什么？\")]),_vm._v(\" \"),_c('p',[_vm._v(\"不是，所谓的安全只是局限于 Setter、Getter 的访问器方法而言的，你对它做 Release 的操作是不会受影响的。这个时候就容易崩溃了。\")]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"_4-实现-isequal-和-hash-方法时要注意什么？\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#_4-实现-isequal-和-hash-方法时要注意什么？\"}},[_vm._v(\"#\")]),_vm._v(\" 4.实现 isEqual 和 hash 方法时要注意什么？\")]),_vm._v(\" \"),_c('ul',[_c('li',[_c('p',[_vm._v(\"hash\")]),_vm._v(\" \"),_c('p',[_vm._v(\"对关键属性的hash值进行位或运算作为hash值\")])]),_vm._v(\" \"),_c('li',[_c('p',[_vm._v(\"isEqual\")]),_vm._v(\" \"),_c('p',[_vm._v(\"==运算符判断是否是同一对象, 因为同一对象必然完全相同\")]),_vm._v(\" \"),_c('p',[_vm._v(\"判断是否是同一类型, 这样不仅可以提高判等的效率, 还可以避免隐式类型转换带来的潜在风险\")]),_vm._v(\" \"),_c('p',[_vm._v(\"判断对象是否是nil, 做参数有效性检查\")]),_vm._v(\" \"),_c('p',[_vm._v(\"各个属性分别使用默认判等方法进行判断\")]),_vm._v(\" \"),_c('p',[_vm._v(\"返回所有属性判等的与结果\")])])]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"_5-id-和-instancetype-有什么区别？\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#_5-id-和-instancetype-有什么区别？\"}},[_vm._v(\"#\")]),_vm._v(\" 5.id 和 instanceType 有什么区别？\")]),_vm._v(\" \"),_c('ul',[_c('li',[_c('p',[_vm._v(\"相同点\")]),_vm._v(\" \"),_c('p',[_vm._v(\"instancetype 和 id 都是万能指针，指向对象。\")])]),_vm._v(\" \"),_c('li',[_c('p',[_vm._v(\"不同点：\")]),_vm._v(\" \"),_c('p',[_vm._v(\"1.id 在编译的时候不能判断对象的真实类型，instancetype 在编译的时候可以判断对象的真实类型。\")]),_vm._v(\" \"),_c('p',[_vm._v(\"2.id 可以用来定义变量，可以作为返回值类型，可以作为形参类型；instancetype 只能作为返回值类型。\")])])]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"_6-self和super的区别\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#_6-self和super的区别\"}},[_vm._v(\"#\")]),_vm._v(\" 6.self和super的区别\")]),_vm._v(\" \"),_c('ul',[_c('li',[_c('p',[_vm._v(\"self调用自己方法，super调用父类方法\")])]),_vm._v(\" \"),_c('li',[_c('p',[_vm._v(\"self是类，super是预编译指令\")])]),_vm._v(\" \"),_c('li',[_c('p',[_vm._v(\"[self class] 和 [super class] 输出是一样的\")])]),_vm._v(\" \"),_c('li',[_c('p',[_vm._v(\"self和super底层实现原理\")]),_vm._v(\" \"),_c('p',[_vm._v(\"1.当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；\")]),_vm._v(\" \"),_c('p',[_vm._v(\"而当使用 super 时，则从父类的方法列表中开始找，然后调用父类的这个方法\")]),_vm._v(\" \"),_c('p',[_vm._v(\"2.当使用 self 调用时，会使用 objc_msgSend 函数：\")]),_vm._v(\" \"),_c('div',{staticClass:\"language-c line-numbers-mode\"},[_c('pre',{pre:true,attrs:{\"class\":\"language-c\"}},[_c('code',[_vm._v(\"id \"),_c('span',{pre:true,attrs:{\"class\":\"token function\"}},[_vm._v(\"objc_msgSend\")]),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\"(\")]),_vm._v(\"id theReceiver\"),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\",\")]),_vm._v(\" SEL theSelector\"),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\",\")]),_vm._v(\" \"),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\".\")]),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\".\")]),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\".\")]),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\")\")]),_vm._v(\"\\n\")])]),_vm._v(\" \"),_c('div',{staticClass:\"line-numbers-wrapper\"},[_c('span',{staticClass:\"line-number\"},[_vm._v(\"1\")]),_c('br')])]),_c('p',[_vm._v(\"第一个参数是消息接收者，第二个参数是调用的具体类方法的 selector，后面是 selector 方法的可变参数。以 [self setName:] 为例，编译器会替换成调用 objc_msgSend 的函数调用，其中 theReceiver 是 self，theSelector 是 @selector(setName:)，这个 selector 是从当前 self 的 class 的方法列表开始找的 setName，当找到后把对应的 selector 传递过去。\")]),_vm._v(\" \"),_c('p',[_vm._v(\"3.当使用 super 调用时，会使用 objc_msgSendSuper 函数：\")]),_vm._v(\" \"),_c('div',{staticClass:\"language-c line-numbers-mode\"},[_c('pre',{pre:true,attrs:{\"class\":\"language-c\"}},[_c('code',[_vm._v(\"id \"),_c('span',{pre:true,attrs:{\"class\":\"token function\"}},[_vm._v(\"objc_msgSendSuper\")]),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\"(\")]),_c('span',{pre:true,attrs:{\"class\":\"token keyword\"}},[_vm._v(\"struct\")]),_vm._v(\" \"),_c('span',{pre:true,attrs:{\"class\":\"token class-name\"}},[_vm._v(\"objc_super\")]),_vm._v(\" \"),_c('span',{pre:true,attrs:{\"class\":\"token operator\"}},[_vm._v(\"*\")]),_vm._v(\"super\"),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\",\")]),_vm._v(\" SEL op\"),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\",\")]),_vm._v(\" \"),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\".\")]),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\".\")]),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\".\")]),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\")\")]),_vm._v(\"\\n\")])]),_vm._v(\" \"),_c('div',{staticClass:\"line-numbers-wrapper\"},[_c('span',{staticClass:\"line-number\"},[_vm._v(\"1\")]),_c('br')])]),_c('p',[_vm._v(\"第一个参数是个objc_super的结构体，第二个参数还是类似上面的类方法的selector\")]),_vm._v(\" \"),_c('div',{staticClass:\"language-c line-numbers-mode\"},[_c('pre',{pre:true,attrs:{\"class\":\"language-c\"}},[_c('code',[_c('span',{pre:true,attrs:{\"class\":\"token keyword\"}},[_vm._v(\"struct\")]),_vm._v(\" \"),_c('span',{pre:true,attrs:{\"class\":\"token class-name\"}},[_vm._v(\"objc_super\")]),_vm._v(\" \"),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\"{\")]),_vm._v(\"\\n\\tid receiver\"),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\";\")]),_vm._v(\"\\n\\tClass superClass\"),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\";\")]),_vm._v(\"\\n\"),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\"}\")]),_c('span',{pre:true,attrs:{\"class\":\"token punctuation\"}},[_vm._v(\";\")]),_vm._v(\"\\n\")])]),_vm._v(\" \"),_c('div',{staticClass:\"line-numbers-wrapper\"},[_c('span',{staticClass:\"line-number\"},[_vm._v(\"1\")]),_c('br'),_c('span',{staticClass:\"line-number\"},[_vm._v(\"2\")]),_c('br'),_c('span',{staticClass:\"line-number\"},[_vm._v(\"3\")]),_c('br'),_c('span',{staticClass:\"line-number\"},[_vm._v(\"4\")]),_c('br')])])])]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"_7-synthesize和-dynamic分别有什么作用？\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#_7-synthesize和-dynamic分别有什么作用？\"}},[_vm._v(\"#\")]),_vm._v(\" 7.@synthesize和@dynamic分别有什么作用？\")]),_vm._v(\" \"),_c('ul',[_c('li',[_c('p',[_vm._v(\"@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;\")])]),_vm._v(\" \"),_c('li',[_c('p',[_vm._v(\"@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。\")])]),_vm._v(\" \"),_c('li',[_c('p',[_vm._v(\"@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。\")])])]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"_8-typeof-和-typeof，typeof-的区别\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#_8-typeof-和-typeof，typeof-的区别\"}},[_vm._v(\"#\")]),_vm._v(\" 8.typeof 和 __typeof，\"),_c('strong',[_vm._v(\"typeof\")]),_vm._v(\" 的区别?\")]),_vm._v(\" \"),_c('ul',[_c('li',[_c('p',[_vm._v(\"__typeof __() 和 __typeof() 是 C语言 的编译器特定扩展，因为标准 C 不包含这样的运算符。 标准 C 要求编译器用双下划线前缀语言扩展（这也是为什么你不应该为自己的函数，变量等做这些）\")])]),_vm._v(\" \"),_c('li',[_c('p',[_vm._v(\"typeof() 与前两者完全相同的，只不过去掉了下划线，同时现代的编译器也可以理解。\")])])]),_vm._v(\" \"),_c('p',[_vm._v(\"所以这三个意思是相同的，但没有一个是标准C，不同的编译器会按需选择符合标准的写法。\")]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"_9-类族\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#_9-类族\"}},[_vm._v(\"#\")]),_vm._v(\" 9.类族\")]),_vm._v(\" \"),_c('p',[_vm._v(\"系统框架中有许多类簇，大部分collection类都是类族。例如NSArray与其可变版本NSMutableArray。这样看来实际上有两个抽象基类，一个用于不可变数组，一个用于可变数组。尽管具备公共接口的类有两个，但任然可以合起来算一个类族。不可变的类定义了对所有数组都通用的方法，而可变类则定义了那些只适用于可变数组的方法。两个类共同属于同一个类族，这意味着二者在实现各自类型的数组时可以共用实现代码，此外还能把可变数组复制成不可变数组，反之亦然。\")]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"_10-struct和class的区别\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#_10-struct和class的区别\"}},[_vm._v(\"#\")]),_vm._v(\" 10.struct和class的区别\")]),_vm._v(\" \"),_c('ul',[_c('li',[_c('p',[_vm._v(\"类： 引用类型（位于栈上面的指针（引用）和位于堆上的实体对象）\")])]),_vm._v(\" \"),_c('li',[_c('p',[_vm._v(\"结构：值类型（实例直接位于栈中）\")])])])])}]\n\nexport { render, staticRenderFns }"]}