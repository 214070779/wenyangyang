---
title: OC基础之常见知识
categories: 
  - 技术
  - iOS基础知识
tags: 
  - null
author: 
  name: 洋仔
date: 2023-08-11 22:41:27
permalink: /pages/7ad2d6/
---

## OC是动态语言，如何理解

OC的动态特性可从三方面描述

- 动态类型识别（Dynamic typing）:最终判定该类的实例类型是在运行期间
- 动态绑定（Dynamic binding）：在运行时确定调用的方法
- 动态加载（Dynamic loading）：在运行期间可添加模块（类、方法）

###  动态类型识别

- OC中有一个可以表示任何实例对象类型的关键字--id，将对象声明为id类型，可根据需要，赋予不同类型的实例对象。
- 父类指针同样也可以指向子类实例对象，编译期指针类型为父类，运行后可判断为具体的某个子类。
- 这段代码也可以很好的解释OC的动态类型识别：NSData *test = [[NSString alloc] init]; 在编译期test被认为NSData类型，运行后则为NSString类型，其值为空字符串("")。


###  动态绑定

关于动态绑定，苹果官网的给的解释为：（determining the method to invoke at runtime）。我理解为运行时决定调用方法（更专业的应该叫消息发送，大家不要纠结这细节哈）。动态绑定是实现OC多态的基础，所谓多态指的是不同对象对同一方法（叫函数也行）有着不同实现，常见于子类继承父类，重写父类方法，不同的子类实现该方法不同，通过父类指针指向子类来完成。


### 动态加载

**1.动态添加属性:**

原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。
对象关联允许开发者对已经存在的类在 Category 中添加自定义的属性：

::: tip

OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) 



参数1：object 是源对象

参数2：value 是被关联的对象

参数3：key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象

参数4：policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义

要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可.

:::
**这个也可以取消关联**

void objc_removeAssociatedObjects(id object)

::: tip 应用情景


给NSObject类添加一个name属性
给UIButton或UIView添加一个单击事件回调属性
给控件（UILable，UIButton，UIView等）添加一个角标显示的信息的属性，以及信息的颜色，字体大小等属性
下面我们以给 UIButton 添加一个监听单击事件的 block 属性为例：

:::
_________________

```
#import <UIKit/UIKit.h>

typedef void(^clickBlock)(void);

@interface UIButton (block)

/*
 * 在分类中声明一个属性时,只会生成setter和getter方法的声明,并不能生成setter和getter方法的
 * 实现以及带下划线的成员变量.
 * 所以, 在分类中有两种方式声明一个属性
 */

/** 第一种写法 */
@property (nonatomic,copy) clickBlock click;

/** 第二种写法 */
//@property clickBlock click;

@end

```


```

#import "UIButton+block.h"
#import <objc/runtime.h>

/** 定义关联的key */
static const void *clickKey = "click";

@implementation UIButton (block)

//Category中的属性，只会生成setter和getter方法，不会生成成员变量

-(void)setClick:(clickBlock)click{
    
    /* 产生关联,让某个对象(name)与当前对象的属性(name)产生关联
     参数1: id object :表示给哪个对象添加关联
     参数2: const void *key : 表示: id类型的key值(以后用这个key来获取属性) 属性名
     参数3: id value : 属性值
     参数4: 策略, 是个枚举(点进去,解释很详细)
     
     单词Associated 关联
     */
    objc_setAssociatedObject(self, clickKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);
    
    [self removeTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];
    
    if (click) {
        [self addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];
    }
}

- (clickBlock)click{
    return objc_getAssociatedObject(self, clickKey);
}

- (void)buttonClick{
    if (self.click) {
        self.click();
    }
}

@end

```

```
UIButton *button = [[UIButton alloc] init];
    
button.frame = self.view.bounds;
    
[self.view addSubview:button];
    
button.click = ^{
    
    NSLog(@"点击了button");
    
};
```


**2.动态添加方法**

动态添加方法，就是使用performSelector来添加方法，也就相当于懒加载机制。
如果一个类的方法很多，加载类到内存的时候耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。

> 首先创建一个对象Child，引入runtime头文件，

```#import <objc/message.h> ```

> 实现动态添加方法，首先要实现这个方法：resolveInstanceMethod。
resolveInstanceMethod调用：当一个方法没有实现，但是又调用了这个，就会调用。

> resolveInstanceMethod作用：知道哪些方法没有实现，从而动态添加方法。

class_addMethod(Class cls, SEL name, IMP imp, const char *types)：
动态添加方法时调用：
1. class:给哪个类添加方法
2. SEL:方法编号
3. IMP:方法的实现，函数入口(指针)  如果是C方法的话可直接写方法名，如果是OC方法的话，可通过class_getMethodImplementation(Class cls, SEL name)方法获得；
4. types:方法类型，返回值类型，是个C字符串，"V@:"表示返回值类型为空，无参，"i@:"返回值为int，无参，"i@:@"，返回值为int，一个参数。

```OC
Panda *pan = [[Panda alloc] init];
    
// 默认Panda，没有实现eat方法，不能直接调用，可以通过performSelector调用，但是会报错。
// 动态添加方法就不会报错
    
/** 无参 */
//[pan performSelector:@selector(eat)];
    
/** 有参 */
[pan performSelector:@selector(eat:) withObject:@521];

```
  
```OC
#import "Panda.h"
#import <objc/runtime.h>

@implementation Panda

// 默认方法都有两个隐式参数，
// 定义添加的方法
void eat(id self, SEL sel, NSNumber *meter)
{
    NSLog(@"\n%@\n%@\n%@",self,NSStringFromSelector(sel),meter);
}

// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.
// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法
+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    
    if (sel == NSSelectorFromString(@"eat:")) {
        // 动态添加eat方法
        
        // 第一个参数：给哪个类添加方法
        // 第二个参数：添加方法的方法编号
        // 第三个参数：添加方法的函数实现（函数地址）
        // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象->self :表示SEL->_cmd
        class_addMethod(self, sel, (IMP) eat, "v@:");
        
        return YES;
    }
    
    return [super resolveInstanceMethod:sel];
}

@end


```
::: warning

- 动态添加的方法的作用就是去处理未实现的实例方法或者是类方法，它的调用时刻: 只要我们调用了一个不存在的方法时，它就会动态方法解析，接下来就会进入消息转发流程，这此过程中我们可以拦截然后动态的添加方法，防止程序崩溃。

- 如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类添加方法解决。

- 有没有使用performSelector，其实主要想问你有没有动态添加过方法。使用performSelector可以调用一个没有实现的方法，但是会报错。

使用场景:

一个类方法非常多，一次性加载到内存，比较耗费资源，为什么动态添加方法? OC都是懒加载，有些方法可能很久不会调用。

比如电商，视频，社交等一些软件会有有收费项目或者会员机制，那么只有在开通会员的时候才会拥有特定功能，然而存在相当一部门用户是没有使用收费功能，或者是没有开通开通会员的，我们就在这些用户使用时不加载这些方法（这个方法的类是要加载的），后面利用Runtime动态的添加这些方法，以达到性能最大化。

:::

**3.动态添加类** 
  
 > 通过objc_allocateClassPair(Class _Nullable superclass, const char * _Nonnull name,size_t extraBytes) 
  添加要动态创建的类，然后添加方法和变量，最终将创建的类注册到runtime中
  objc_registerClassPair(Class _Nonnull cls) 

  导入头文件#import <objc/runtime.h>，动态添加类，创建一个继承 NSString 的类NSStringSubClass类，如下代码

```
// 类名也可以直接使用C字符串写法 ”NSStringSubClass“
NSString *className = @"NSStringSubClass";  

// Creates a new class and metaclass.
Class newClass = objc_allocateClassPair(NSString.class, className.UTF8String, 0);    
class_addMethod(newClass, @selector(eat), (IMP)EatFunction, "v@:");
objc_registerClassPair(newClass);

```

调用objc_allocateClassPair()函数，对类对（class and metaClass）进行分配内存，Pair的意思就是一对。三个参数，

一是父类：NSString类；

二是类名称：“NSStringSubClass”；

三是额外字节：0。



**动态加态资源**

> 根据需求加载所需要的资源，这点很容易理解，对于iOS开发来说，基本就是根据不同的机型做适配。最经典的例子就是在Retina设备上加载@2x的图片，而在老一些的普通屏设备上加载原图。




## 面向对像编程

面向对象编程有三大特性：封装、继承、多态。

- 封装： 隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。
- 继承： 提高代码复用性；建立了类之间的关系；子类可以拥有父类的所有成员变量的方法；继承是多态的前提。
- 多态： 所谓多态指的是不同对象对同一方法（叫函数也行）有着不同实现，常见于子类继承父类，重写父类方法，不同的子类实现该方法不同，通过父类指针指向子类来完成。


### 面向对象和面向过程的区别?

- 面向过程:注重的是解决问题的步骤,比如C语言

- 面向对象:关注的是解决问题的去要那些对象,OC语言就是面向对象
  

### 对象方法和类方法的区别?

- 对象方法:以减号开头,只可以被对象调用,可以访问成员变量

- 类方法:以加号开头只能用类名调用,对象不可以调用,类方法不能访问成员变量


### 手写单例

```

static ClassName *_instance;
+ (instancetype)sharedInstance{
   @synchronized (self) {
       if(!_instance)   {
           _instance = [self alloc]init];
       }
    }
    return _instance;
} 

```

方式二: 注意多线程问题 GCDdispatch_once 默认是线程安全的

```

static ClassName *_instance;
  + (instancetype)sharedInstance{
      static dispatch_one_t oneToken;
      dispatch_once(&onetoken,^{
          _instance = [self alloc]init];
      });
      return _instance;
  }
  
  + (instancetype)allocWithZone:(NSZone *) zone{
    static dispatch_t onetoken;
    dispatch_once(&oncetoken ^{
        _instance = [super allocwithzone:zone];
    })
    retun _instance
  }

```

###  什么是僵尸对象? 野指针?

- 僵尸对象: 已经被销毁的对象(不能再使用的对象),内存已经被回收的对象。
- 野指针: 指向僵尸对象(不可用内存/已经释放的内存地址)的指针

```

NSObject *obj = [NSObject new];
[obj release]; // obj 指向的内存地址已经释放了,
obj 如果再去访问的话就是野指针错误了.
野指针错误形式在Xcode中通常表现为：Thread 1：EXC_BAD_ACCESS，因为你访问了一块已经不属于你的内存。

```

### C和 OC 如何混编

xcode可以识别一下几种扩展名文件:

.m文件,可以编写 OC语言 和 C 语言代码
.cpp: 只能识别C++ 或者C语言(C++兼容C)
.mm: 主要用于混编 C++和OC代码,可以同时识别OC,C,C++代码


### 遇到过BAD_ACCESS的错误吗？你是怎样调试的？

BAD_ACCESS 报错属于内存访问错误，会导致程序崩溃，错误的原因是访问了野指针(悬挂指针)。

设置全局断点快速定位问题代码所在行。
开启僵尸对象诊断
Analyze分析
重写object的respondsToSelector方法，现实出现EXEC_BAD_ACCESS前访问的最后一个object。
Xcode 7 已经集成了BAD_ACCESS捕获功能：Address Sanitizer。 用法如下：在配置中勾选✅Enable Address Sanitizer。

### Objective-C 如何实现多重继承？

Object-c的类没有多继承,只支持单继承,如果要实现多继承的话，可使用如下几种方式间接实现

通过组合实现

A和B组合，作为C类的组件

通过协议实现

C类实现A和B类的协议方法

消息转发实现

forwardInvocation:方法

## 什么是类簇

类簇是Foundation框架广泛使用的设计模式。类簇在公共抽象父类下对多个私有的具体子类进行分组。以这种方式对类进行分组简化了面向对象框架的公共可见体系结构，而不会降低其功能丰富度。类簇是基于抽象工厂设计模式的。

OC中有哪些类簇呢？NSData、NSArray、NSDictionary、NSString、NSNumber等都是类簇。日常开发debug过程中我们可能会发现_NSCFString、__NSArrayI这样的类，其实这就是其类簇下面的私有子类

为什么苹果要这样设计呢？以NSArray为例，为了保持数组存取的高效，针对不同情况（可变、不可变、单元素等情况）必然要有相应的子类来优化实现。如果全部都用可见子类来实现的话，那么对于程序员来说，就要熟知大量的子类及其API，并且在调用的时候也要分情况去调用，这样使用起来太复杂了。而且如果子类实现改变的话，有可能导致接口也改变，框架API变化也就更加频繁，不利于使用。
为了解决这个问题，NSArray和NSMutableArray作为公开抽象父类，抽象了array功能的接口，但是具体的实现则是通过私有的具体子类来实现。再结合抽象工厂设计模式，程序员就可以通过抽象父类引用而指向私有具体子类，由子类根据自身情况实现父类抽象的方法。这样接口十分简洁，框架底层子类变化时也不会影响到接口的变化，增强了接口稳定性。


## APNS的推送机制原理


1. 由App向iOS设备发送一个注册通知，用户需要同意系统发送推送。
2. iOS向APNs远程推送服务器发送App的Bundle Id和设备的UDID。
3. APNs根据设备的UDID和App的Bundle Id生成deviceToken再发回给App。
4. App再将deviceToken发送给远程推送服务器(自己的服务器), 由服务器保存在数据库中。
5. 当自己的服务器想发送推送时, 在远程推送服务器中输入要发送的消息并选择发给哪些用户的deviceToken，由远程推送服务器发送给APNs。
6. APNs根据deviceToken发送给对应的用户。
- APNs 服务器就是苹果专门做远程推送的服务器。
- deviceToken是由APNs生成的一个专门找到你某个手机上的App的一个标识码。
- deviceToken 可能会变,如果你更改了你项目的bundle Identifier或者APNs服务器更新了可能会变。
