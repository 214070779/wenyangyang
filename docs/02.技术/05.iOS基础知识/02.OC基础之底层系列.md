---
title: OC基础之底层系列
categories: 
  - 技术
  - iOS基础知识
tags: 
  - null
author: 
  name: yangyang.wen
date: 2023-08-11 22:41:27
permalink: /pages/d13cac/
---

## 一个OC对象占用多少内存

系统分配了16个字节给NSObject对象（通过malloc_size函数获得）
但NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得）


## OC对象的分类

OC对象 可以分为3种:
1. instance对象 (实例对象)
2. class对象 (类对象)
3. meta-class对象 (元类对象)

## instance对象 (实例对象)

instance对象就是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象

instance对象在内存中存储的信息包括
    -isa指针
    -其他成员变量
## Class对象 (类对象)

我们平时说的类,其实也是对象,称为类对象, 每个类在内存中有且只有一个class对象

class对象在内存中存储的信息主要包括

- isa指针

- superclass指针

- 类的属性信息（@property）、类的对象方法信息（instance method）

- 类的协议信息（protocol）、类的成员变量信息（ivar）
......

## meta-Class 元类对象

每个类在内存中有且只有一个meta-class对象

// 将类对象当做参数传入，获得元类对象
Class objectMetaClass = object_getClass(objectClass5);

objectMetaClass是NSObject的meta-class对象（元类对象）

每个类在内存中有且只有一个meta-class对象

meta-class对象和class对象的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括

- isa指针
- superclass指针
- 类的类方法信息（class method）
  
### 为什么要设计metaclass?

先说结论: 为了更好的复用传递消息.metaclass只是需要实现复用消息传递为目的工具.而Objective-C所有的类默认都是同一个MetaClass(通过isa指针最终指向metaclass). 因为Objective-C的特性基本上是照搬的Smalltalk,Smalltalk中的MetaClass的设计是Smalltalk-80加入的.所以Objective-C也就有了metaclass的设计.

![继承关系](https://cdn.staticaly.com/gh/214070779/picx-images-hosting@master/20230813/继承关系.4n42h8e5u8a0.webp)

## isa指针

instance的isa指向class
当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用

class的isa指向meta-class
当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用

## superClass 指针

class对象的superclass指针

@interface Student: Person

@interfce  Person: NSObject

当Student的instance对象要调用Person的对象方法时，会先通过isa找到Student的class，
然后通过superclass找到Person的class，最后找到对象方法的实现进行调用


meta-class对象的superclass指针

当Student的class要调用Person的类方法时，会先通过isa找到Student的meta-class，
然后通过superclass找到Person的meta-class，最后找到类方法的实现进行调用


::: tip

类对象存储实例方法列表等信息

元类对象存储类方法列表等信息
### 对像方法

1. 实例对象(instance)要调用对象方法1.通过isa指针 -> 找到自己所属的类对象 -> 查找并调用方法

2. 如果在自己的类对象没有找到方法，通过类对象的superclass指针 -> 找到父类的类对象 ->查找并调用方法
   
3. 如果还没有找到，就通过superclass指针一直通过继承关系往上找，直到基类的类对象，如果还是没有找到，抛出异常

### 类方法

1. 类对象通过isa指针 -> 找到自己的元类对象 -> 查找并调用方法

2. 如果没有找到，通过元类对象的superclass指针 -> 找到父类的元类对象 -> 查找并且调用方法

3. 如果还是没有找到，根据继承体系，通过元类对象的superclass指针一直找到基类的元类对象，查找并调用方法

4. 如果基类的元类对象也找不到该类方法，会通过基类元类对象的superclass指针找到基类的类对象，查找有没有同名的对象方法，找到就调用，没有就抛出异常


:::