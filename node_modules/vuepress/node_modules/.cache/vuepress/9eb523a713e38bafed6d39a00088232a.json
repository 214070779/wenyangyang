{"remainingRequest":"/Users/yangyangwen/Desktop/wenyangyang/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/yangyangwen/Desktop/wenyangyang/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/yangyangwen/Desktop/wenyangyang/docs/iOS-Summary/Foundation.md?vue&type=template&id=4886587b&","dependencies":[{"path":"/Users/yangyangwen/Desktop/wenyangyang/docs/iOS-Summary/Foundation.md","mtime":1568205954000},{"path":"/Users/yangyangwen/Desktop/wenyangyang/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yangyangwen/Desktop/wenyangyang/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/yangyangwen/Desktop/wenyangyang/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yangyangwen/Desktop/wenyangyang/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/yangyangwen/Desktop/wenyangyang/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"foundation\"><a class=\"header-anchor\" href=\"#foundation\">#</a> Foundation</h1>\n<h2 id=\"_1-nil、nil、nsnull-有什么区别？\"><a class=\"header-anchor\" href=\"#_1-nil、nil、nsnull-有什么区别？\">#</a> 1.nil、NIL、NSNULL 有什么区别？</h2>\n<ul>\n<li>\n<p>nil、NIL 可以说是等价的，都代表内存中一块空地址。</p>\n</li>\n<li>\n<p>NSNULL 代表一个指向 nil 的对象。</p>\n</li>\n</ul>\n<h2 id=\"_2-如何实现一个线程安全的-nsmutablearray\"><a class=\"header-anchor\" href=\"#_2-如何实现一个线程安全的-nsmutablearray\">#</a> 2.如何实现一个线程安全的 NSMutableArray?</h2>\n<p>NSMutableArray是线程不安全的，当有多个线程同时对数组进行操作的时候可能导致崩溃或数据错误</p>\n<ul>\n<li>\n<p>线程锁：使用线程锁对数组读写时进行加锁</p>\n</li>\n<li>\n<p>派发队列：在《Effective Objective-C 2.0..》书中第41条：多用派发队列，少用同步锁中指出：使用“串行同步队列”（serial synchronization queue），将读取操作及写入操作都安排在同一个队列里，即可保证数据同步。而通过并发队列，结合GCD的栅栏块（barrier）来不仅实现数据同步线程安全，还比串行同步队列方式更高效。</p>\n</li>\n</ul>\n<h2 id=\"_3-atomic-修饰的属性是绝对安全的吗？为什么？\"><a class=\"header-anchor\" href=\"#_3-atomic-修饰的属性是绝对安全的吗？为什么？\">#</a> 3.atomic 修饰的属性是绝对安全的吗？为什么？</h2>\n<p>不是，所谓的安全只是局限于 Setter、Getter 的访问器方法而言的，你对它做 Release 的操作是不会受影响的。这个时候就容易崩溃了。</p>\n<h2 id=\"_4-实现-isequal-和-hash-方法时要注意什么？\"><a class=\"header-anchor\" href=\"#_4-实现-isequal-和-hash-方法时要注意什么？\">#</a> 4.实现 isEqual 和 hash 方法时要注意什么？</h2>\n<ul>\n<li>\n<p>hash</p>\n<p>对关键属性的hash值进行位或运算作为hash值</p>\n</li>\n<li>\n<p>isEqual</p>\n<p>==运算符判断是否是同一对象, 因为同一对象必然完全相同</p>\n<p>判断是否是同一类型, 这样不仅可以提高判等的效率, 还可以避免隐式类型转换带来的潜在风险</p>\n<p>判断对象是否是nil, 做参数有效性检查</p>\n<p>各个属性分别使用默认判等方法进行判断</p>\n<p>返回所有属性判等的与结果</p>\n</li>\n</ul>\n<h2 id=\"_5-id-和-instancetype-有什么区别？\"><a class=\"header-anchor\" href=\"#_5-id-和-instancetype-有什么区别？\">#</a> 5.id 和 instanceType 有什么区别？</h2>\n<ul>\n<li>\n<p>相同点</p>\n<p>instancetype 和 id 都是万能指针，指向对象。</p>\n</li>\n<li>\n<p>不同点：</p>\n<p>1.id 在编译的时候不能判断对象的真实类型，instancetype 在编译的时候可以判断对象的真实类型。</p>\n<p>2.id 可以用来定义变量，可以作为返回值类型，可以作为形参类型；instancetype 只能作为返回值类型。</p>\n</li>\n</ul>\n<h2 id=\"_6-self和super的区别\"><a class=\"header-anchor\" href=\"#_6-self和super的区别\">#</a> 6.self和super的区别</h2>\n<ul>\n<li>\n<p>self调用自己方法，super调用父类方法</p>\n</li>\n<li>\n<p>self是类，super是预编译指令</p>\n</li>\n<li>\n<p>[self class] 和 [super class] 输出是一样的</p>\n</li>\n<li>\n<p>self和super底层实现原理</p>\n<p>1.当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；</p>\n<p>而当使用 super 时，则从父类的方法列表中开始找，然后调用父类的这个方法</p>\n<p>2.当使用 self 调用时，会使用 objc_msgSend 函数：</p>\n<!--beforebegin--><div class=\"language-c line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-c\"><code>id <span class=\"token function\">objc_msgSend</span><span class=\"token punctuation\">(</span>id theReceiver<span class=\"token punctuation\">,</span> SEL theSelector<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br></div><!--beforeend--></div><!--afterend--><p>第一个参数是消息接收者，第二个参数是调用的具体类方法的 selector，后面是 selector 方法的可变参数。以 [self setName:] 为例，编译器会替换成调用 objc_msgSend 的函数调用，其中 theReceiver 是 self，theSelector 是 @selector(setName:)，这个 selector 是从当前 self 的 class 的方法列表开始找的 setName，当找到后把对应的 selector 传递过去。</p>\n<p>3.当使用 super 调用时，会使用 objc_msgSendSuper 函数：</p>\n<!--beforebegin--><div class=\"language-c line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-c\"><code>id <span class=\"token function\">objc_msgSendSuper</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">objc_super</span> <span class=\"token operator\">*</span>super<span class=\"token punctuation\">,</span> SEL op<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br></div><!--beforeend--></div><!--afterend--><p>第一个参数是个objc_super的结构体，第二个参数还是类似上面的类方法的selector</p>\n<!--beforebegin--><div class=\"language-c line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-c\"><code><span class=\"token keyword\">struct</span> <span class=\"token class-name\">objc_super</span> <span class=\"token punctuation\">{</span>\n\tid receiver<span class=\"token punctuation\">;</span>\n\tClass superClass<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br></div><!--beforeend--></div><!--afterend--></li>\n</ul>\n<h2 id=\"_7-synthesize和-dynamic分别有什么作用？\"><a class=\"header-anchor\" href=\"#_7-synthesize和-dynamic分别有什么作用？\">#</a> 7.@synthesize和@dynamic分别有什么作用？</h2>\n<ul>\n<li>\n<p>@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;</p>\n</li>\n<li>\n<p>@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。</p>\n</li>\n<li>\n<p>@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</p>\n</li>\n</ul>\n<h2 id=\"_8-typeof-和-typeof，typeof-的区别\"><a class=\"header-anchor\" href=\"#_8-typeof-和-typeof，typeof-的区别\">#</a> 8.typeof 和 __typeof，<strong>typeof</strong> 的区别?</h2>\n<ul>\n<li>\n<p>__typeof __() 和 __typeof() 是 C语言 的编译器特定扩展，因为标准 C 不包含这样的运算符。 标准 C 要求编译器用双下划线前缀语言扩展（这也是为什么你不应该为自己的函数，变量等做这些）</p>\n</li>\n<li>\n<p>typeof() 与前两者完全相同的，只不过去掉了下划线，同时现代的编译器也可以理解。</p>\n</li>\n</ul>\n<p>所以这三个意思是相同的，但没有一个是标准C，不同的编译器会按需选择符合标准的写法。</p>\n<h2 id=\"_9-类族\"><a class=\"header-anchor\" href=\"#_9-类族\">#</a> 9.类族</h2>\n<p>系统框架中有许多类簇，大部分collection类都是类族。例如NSArray与其可变版本NSMutableArray。这样看来实际上有两个抽象基类，一个用于不可变数组，一个用于可变数组。尽管具备公共接口的类有两个，但任然可以合起来算一个类族。不可变的类定义了对所有数组都通用的方法，而可变类则定义了那些只适用于可变数组的方法。两个类共同属于同一个类族，这意味着二者在实现各自类型的数组时可以共用实现代码，此外还能把可变数组复制成不可变数组，反之亦然。</p>\n<h2 id=\"_10-struct和class的区别\"><a class=\"header-anchor\" href=\"#_10-struct和class的区别\">#</a> 10.struct和class的区别</h2>\n<ul>\n<li>\n<p>类： 引用类型（位于栈上面的指针（引用）和位于堆上的实体对象）</p>\n</li>\n<li>\n<p>结构：值类型（实例直接位于栈中）</p>\n</li>\n</ul>\n</div>\n",null]}