---
title: CADisplayLink 与 NSTimer 有什么不同
date: 2024-09-03 10:23:02
permalink: /pages/8a43f9/
---
## CADisplayLink 与 NSTimer 有什么不同?

**1.原理不同**

`CADisplayLink`是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。`CADisplayLink`以特定模式注册到`runloop`后， 每当屏幕显示内容刷新结束的时候，`runloop`就会向`CADisplayLink`指定的`target`发送一次指定的`selector`消息， `CADisplayLink`类对应的`selector`就会被调用一次。

`NSTimer`以指定的模式注册到`runloop`后，每当设定的周期时间到达后，`runloop`会向指定的`target`发送一次指定的`selector`消息。

**2.周期设置方式不同**

iOS设备的屏幕刷新频率(FPS)是60Hz，因此`CADisplayLink`的`selector`默认调用周期是每秒60次，这个周期可以通过`frameInterval`属性设置，`CADisplayLink`的`selector`每秒调用次数=60/`frameInterval`。比如当`frameInterval`设为2，每秒调用就变成30次。因此，`CADisplayLink`周期的设置方式略显不便。

`NSTimer`的`selector`调用周期可以在初始化时直接设定，相对就灵活的多。

**3、精确度不同**

iOS设备的屏幕刷新频率是固定的，`CADisplayLink`在正常情况下会在每次刷新结束都被调用，精确度相当高。

`NSTimer`的精确度就显得低了点，比如`NSTimer`的触发时间到的时候，`runloop`如果在阻塞状态，触发时间就会推迟到下一个`runloop`周期。并且`NSTimer`新增了`tolerance`属性，让用户可以设置可以容忍的触发的时间的延迟范围。

**4、使用场景**

`CADisplayLink`使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。

`NSTimer`的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。

## 一、什么是CADisplayLink

简单地说，它就是一个定时器，每隔几毫秒刷新一次屏幕。

`CADisplayLink`是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。我们在应用中创建一个新的`CADisplayLink`对象，把它添加到一个`runloop`中，并给它提供一个`target`和`selector`在屏幕刷新的时候调用。

一但`CADisplayLink`以特定的模式注册到`runloop`之后，每当屏幕需要刷新的时候，`runloop`就会调用`CADisplayLink`绑定的`target`上的`selector`，这时`target`可以读到`CADisplayLink`的每次调用的时间戳，用来准备下一帧显示需要的数据。例如一个视频应用使用时间戳来计算下一帧要显示的视频数据。在UI做动画的过程中，需要通过时间戳来计算UI对象在动画的下一帧要更新的大小等等。

在添加进`runloop`的时候我们应该选用高一些的优先级，来保证动画的平滑。可以设想一下，我们在动画的过程中，`runloop`被添加进来了一个高优先级的任务，那么，下一次的调用就会被暂停转而先去执行高优先级的任务，然后在接着执行`CADisplayLink`的调用，从而造成动画过程的卡顿，使动画不流畅。

## 二、NSTimer循环引用原因及解决方案

## NSTimer创建

第一种创建方式

```
self.timer = [NSTimer timerWithTimeInterval:1
                                     target:self
                                   selector:@selector(fireHome)
                                   userInfo:nil
                                    repeats:YES];
[[NSRunLoop currentRunLoop] addTimer:self.timer
                                  forMode:NSDefaultRunLoopMode];
```

- 如果在主线程里创建，需要修改下Mode为NSRunLoopCommonModes，不然，当滚动事件发生时，会导致NSTimer不执行，主线程的RunLoop是默认开启的，所以不需要[[NSRunLoop currentRunLoop] run]。
- 如果在子线程里创建，且当前线程里无滚动事件，则不需要修改Mode，子线程的RunLoop默认不开启的，需要手动加入`Runloop`：

第二种创建方式

```
self.timer = [NSTimer scheduledTimerWithTimeInterval:1
                                              target:self
                                            selector:@selector(fireHome)
                                            userInfo:nil
                                             repeats:YES];
```

## 循环引用分析

说到循环引用,大家都会想到有weakself替换self去解决,比如上面的写法改为

```
__weak typeof(self) weakSelf = self;
self.timer = [NSTimer timerWithTimeInterval:1
                                     target:weakSelf
                                   selector:@selector(fireHome)
                                   userInfo:nil
                                    repeats:YES];
[[NSRunLoop currentRunLoop] addTimer:self.timer
                                  forMode:NSDefaultRunLoopMode];
```

**同事: 为什么timer都弱引用了target,还是释放不了**

- `self` 强持有 `timer` 我们都能直接看出来，那么`timer`是什么时候强持有 `self`的呢？
- ![截屏2021-10-08 下午4.33.01.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bc96ed6a5a445a0b684f773ecc8a801~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

看苹果官方文档可知：`target`方法中，`timer`对`self`对象进行了强持有，因此造成了循环引用。

- 但是当我们按照惯例用`weakSelf`去打破强引用的时候，发现`weakSelf`没有打破循环引用，`timer`仍然在运行。

- 即 `self -> timer -> weakSelf -> self`。

来看看`__weak typeof(self) weakSelf = self;`做了什么

![869753-26f8fb55fde27308.webp](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/970b5b79fe9449c0883a6f81e4a70193~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

> 从上图可知，`weakSelf`和`self`两个指针地址不同但内存空间地址相同，也就是两个对象同时持有同一个内存空间.相当于NStimer间接的持有了self,所以weakSelf并没有打破循环关系

** 同事: 不使用属性或者成员变量切断当前类对timer的强引用,可以吧

```
NSTimer *timer = [NSTimer timerWithTimeInterval:1
                                     target:weakSelf
                                   selector:@selector(fireHome)
                                   userInfo:nil
                                    repeats:YES];
[[NSRunLoop currentRunLoop] addTimer:self.timer
                                  forMode:NSDefaultRunLoopMode];
```

timer还是释放不了,原因如下

![1335883-872d4c69c289a08f.webp](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/981ecc1a520b4d5983004ccb6d06ab7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

> 主线程的Runloop在程序运行期间是不会销毁的,它比self的生命周期都长,也就是runloop引用着timer,timer就不会销毁,timer引用着target,target也不会销毁.**从runloop引用着timer这个思路来想,要打破循环,只能从timer引用target这个层面来打破**

## 解决方案

通过上面的分析,我们知道需要打破的地方就是timer对self的强引用

![截屏2021-10-08 下午5.28.56.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b5e3c1d44734771bb5408df16806d43~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

### 方案一：使用更新后的API

在iOS 10以后系统，苹果针对NSTimer进行了优化，使用Block回调方式，解决了循环引用问题。

```
  [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {
       // Do some things
    }];
```

### 方案二： 在当前页面消失的时候释放timer对象

使用`(void)didMoveToParentViewController:(UIViewController *)parent`方法，在这个方法里清掉定时器，就会释放Timer对象，也就解决了强引用。即调用dealloc方法了。

```
//生命周期  移除childVC的时候
- (void)didMoveToParentViewController:(UIViewController *)parent {
    if (parent == nil) {
        [self.myTimer invalidate];
        self.myTimer = nil;
    }
}
```

缺点: 针对PresentVC不适用

### 方案三： 中间件方法

```
//定义个中间件属性
@property (nonatomic, strong) id target;

  _target = [NSObject new];
  class_addMethod([_target class], @selector(testTimer), (IMP)timerIMP, "v@:");
    //这里换成_target  不用self了。  这就没有了循环引用了
  self.myTimer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:_target selector:@selector(testTimer) userInfo:nil repeats:YES];
 [[NSRunLoop currentRunLoop] addTimer:self.myTimer forMode:NSDefaultRunLoopMode];

void timerIMP(id self, SEL _cmd) {
    NSLog(@"Do some things");
}

//停止Timer
- (void)dealloc {
    [self.myTimer invalidate];
    self.myTimer = nil;

    NSLog(@"Timer dealloc");
}
```

### 方案四： 使用NSProxy类

新建一个类TimerProxy，继承NSProxy,设置一个属性

```
//注意这里要使用weak
@property (nonatomic, weak) id target;
```

实现方法转发

```
/** 方法签名 */
- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel {
    return [self.target methodSignatureForSelector:sel];
}
/** 消息转发 */
- (void)forwardInvocation:(NSInvocation *)invocation {
    [invocation invokeWithTarget:self.target];
}

在你需要的地方，然后导入TimerProxy头文件使用
@property (nonatomic, strong) TimerProxy *timerProxy;
    _timerProxy = [TimerProxy alloc];//注意这里只有alloc方法
    //self弱引用所以可以被释放
    _timerProxy.target = self;
    self.myTimer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:_timerProxy selector:@selector(testTimer) userInfo:nil repeats:YES];
```

### 方案五： 自定义Timer类

1. 自定义一个类CustomTimer，定义两个属性，包括timer和target，timer就是真实的NSTimer对象，这里的target不在是timer的target，而是我们外面真正实现业务的对象
   
   ```
   @property (nonatomic, strong) NSTimer *timer;
   //target使用weak修饰
   @property (nonatomic, weak) id target;
   ```

2.self作为timer的target，实现timer回调方法handler:，同时创建一个NSInvocation对象，用于外部真正target的方法调用，invocation通过userInfo参数传递

```
- (instancetype)initWithTimeInterval:(NSTimeInterval)interval
                                   target:(id)target
                                 selector:(SEL)selector
                                  repeats:(BOOL)repeat
{
    self = [super init];
    if (self) {
        NSMethodSignature *methodSignature = [target methodSignatureForSelector:selector];
        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSignature];
        invocation.selector = selector;
        invocation.target = target;
        self.target = target;
        self.timer = [NSTimer scheduledTimerWithTimeInterval:interval target:self selector:@selector(handler:) userInfo:invocation repeats:repeat];
    }
    return self;
}
```

3.处理回调 在handler:中判断弱引用属性target是否为空，不为空则通过invocation调用target方法，如果为空则释放timer

```
- (void)handler:(NSTimer *)timer
{
    NSInvocation *invocation = [timer userInfo];
    if (self.target) {
        [invocation invoke];
    }else{
        [self invalidate];
    }
}

- (void)invalidate
{
    [self.timer invalidate];
    self.timer = nil;
}
```

### 方案六：类似系统API,使用block方式

```
@implementation NSTimer (BlockTimer)

+ (NSTimer *)bt_timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void(^)(NSTimer *timer))block{

    return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(handler:) userInfo:[block copy] repeats:repeats];
}

+ (void)handler:(NSTimer *)timer{

    void (^block)(NSTimer *timer) = timer.userInfo;
    if (block) {
        block(timer);
    }
}
@end
```
